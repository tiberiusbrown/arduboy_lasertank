import input;
import level;
import render;

// returns dir if laser reflected
// returns 4 otherwise
u8 mirror_reflect(u8 mirror_dir, u8 laser_dir)
{
    // 0: reflects 1->0, 2->3
    // 1: reflects 2->1, 3->0
    // 2: reflects 3->2, 0->1
    // 3: reflects 0->3, 1->2
    u8 t = (u8(laser_dir - mirror_dir - 1) & 3);
    if(t <= 1)
        return t == 0 ? u8(laser_dir - 1) & 3 : u8(laser_dir + 1) & 3;
    return 4;
}

void at_scan(u8 dir)
{
    if(shooting)
        return;

    // scan from tankx, tanky for obj
    i8 dx = DIRX[dir];
    i8 dy = DIRY[dir];
    dir = (dir + 2) & 3;
    u8 obj = T_ANTITANK + dir * 4;
    u8 x = tankx + dx;
    u8 y = tanky + dy;
    while(x < 16 && y < 16)
    {
        u8 i = y * 16 + x;
        if(tiles[i] >= T_FIRST_SOLID)
            break;
        if(objects[i] == obj)
        {
            shootx = x - dx;
            shooty = y - dy;
            shootdir = dir;
            shooting = true;
            return;
        }
        if(objects[i] >= T_FIRST_SOLID)
            break;
        x += dx;
        y += dy;
    }
}

void tank_just_moved()
{
    u8 tanki = tanky * 16 + tankx;
    u8 t = tiles[tanki];
    just_moved = false;
    switch(t)
    {
        case(T_TUNNEL ... T_TUNNEL + 31)
        {
            u8 ti = find_other_tunnel(tanki);
            if(ti != tanki)
            {
                tanky = ti >> 4;
                tankx = ti & 15;
            }
            else
            {
                // black hole
                dead = true;
            }
        }
        case(T_ICE, T_ICE_CRACKED)
        {
            if(t == T_ICE_CRACKED)
            {
                tiles[tanki] = T_WATER;
                just_moved = true;
            }
            u8 nx = tankx + DIRX[just_moved_dir];
            u8 ny = tanky + DIRY[just_moved_dir];
            if(!solid(nx, ny))
            {
                tankx = nx;
                tanky = ny;
                anim_frame = anim_frames;
                just_moved = true;
            }
        }
    }
}

void tank_update()
{
    u8 tanki = tanky * 16 + tankx;
    u8 t = tiles[tanki];
    switch(t)
    {
        case(T_WATER)
            dead = true;
        case(T_ONEWAY ... T_ONEWAY + 15)
        {
            u8 dir = u8(t - T_ONEWAY) >> 2;
            u8 nx = tankx + DIRX[dir];
            u8 ny = tanky + DIRY[dir];
            if(!solid(nx, ny))
            {
                tankx = nx;
                tanky = ny;
                anim_frame = anim_frames;
                just_moved = true;
                just_moved_dir = dir;
            }
        }
    }
}

void play()
{
    if(tiles[tanky * 16 + tankx] == T_FLAG)
    {
        render_level();
        constexpr u8 W = 52;
        constexpr u8 H = 17;
        constexpr u8 X = 64 - W / 2;
        constexpr u8 Y = 32 - H / 2;
        $draw_filled_rect(X, Y, W, H, BLACK);
        $draw_filled_rect(X + 1, Y + 1, W - 2, H - 2, WHITE);
        $draw_filled_rect(X + 3, Y + 3, W - 6, H - 6, BLACK);
        $set_text_font(FONT_PIXELOIDSANSBOLD);
        $draw_text(42, 35, "Victory!");
        if($just_pressed(B_BUTTON))
            state = STATE_SELECT;
        else if($just_pressed(A_BUTTON))
        {
            current_level += 1;
            if(current_level >= len(LEVELSETS[current_set].levels))
            {
                current_level -= 1;
                state = STATE_SELECT;
            }
            else
            {
                load_level();
            }
            select_levels[current_set] = current_level;
        }
        return;
    }

    if(dead)
    {
        render_level();
        constexpr u8 W = 45;
        constexpr u8 H = 15;
        constexpr u8 X = 64 - W / 2;
        constexpr u8 Y = 32 - H / 2;
        $draw_filled_rect(X, Y, W, H, BLACK);
        $draw_filled_rect(X + 1, Y + 1, W - 2, H - 2, WHITE);
        $draw_filled_rect(X + 3, Y + 3, W - 6, H - 6, BLACK);
        $set_text_font(FONT_PIXELOIDSANSBOLD);
        $draw_text(46, 36, "Defeat");
        if($just_pressed(B_BUTTON))
            state = STATE_SELECT;
        else if($just_pressed(A_BUTTON))
            load_level();
        return;
    }

    if(anim_frame != 0)
        anim_frame -= 1;
    bool anim = anim_frame == 0;

    if(moving && anim)
    {
        u8 mi = movey * 16 + movex;
        moving = false;
        switch(tiles[mi])
        {
            case(T_ICE_CRACKED)
            {
                tiles[mi] = T_WATER;
                moving = true;
            }
            case(T_WATER)
            {
                if(objects[mi] == T_BLOCK_MOVE)
                    tiles[mi] = T_WATER_FILL;
                objects[mi] = T_DIRT;
            }
        }
        u8 nx = movex + DIRX[movedir];
        u8 ny = movey + DIRY[movedir];
        if(!solid(nx, ny))
        {
            u8 ni = ny * 16 + nx;
            u8& obj0 = objects[mi];
            u8& obj1 = objects[ny * 16 + nx];
            obj1 = obj0;
            obj0 = T_DIRT;
            switch(tiles[ni])
            {
                case(T_WATER)
                {
                    if(obj1 == T_BLOCK_MOVE)
                        tiles[ni] = T_WATER_FILL;
                    obj1 = T_DIRT;
                }
                case(T_TUNNEL ... T_TUNNEL + 31)
                {
                    u8 ti = find_other_tunnel(ni);
                    if(ti != ni)
                        objects[ti] = obj1;
                    obj1 = T_DIRT;
                }
                case(T_ICE, T_ICE_CRACKED)
                {
                    movex = nx;
                    movey = ny;
                    moving = true;
                }
            }
        }
    }

    if(just_moved && anim)
        tank_just_moved();

    // scan for anti-tanks
    if(anim && !shooting)
    {
        at_scan(DIR_U);
        at_scan(DIR_R);
        at_scan(DIR_D);
        at_scan(DIR_L);
    }

    if(anim)
        tank_update();

    if(shooting && anim)
    {
        u8 si = shooty * 16 + shootx;
        u8 t = tiles[si];
        u8 obj = objects[si];
        if(shootx == tankx && shooty == tanky)
        {
            dead = true;
        }
        else if(!opaque(shootx, shooty))
        {
            shootx += DIRX[shootdir];
            shooty += DIRY[shootdir];
            shooting = shootx < 16 && shooty < 16;
            anim_frame = anim_frames;
        }
        else
        {
            u8 si = shooty * 16 + shootx;
            u8 obj = objects[si];
            if(obj == T_DIRT)
                obj = tiles[si];
            shooting = false;
            movex = shootx;
            movey = shooty;
            movedir = shootdir;
            switch(obj)
            {
                case(T_BLOCK_MOVE)
                    moving = true;
                case(T_MIRROR ... T_MIRROR + 15)
                {
                    u8 d = mirror_reflect((obj >> 2) & 3, shootdir);
                    if(d < 4)
                    {
                        shooting = true;
                        shootdir = d;
                        shootx += DIRX[shootdir];
                        shooty += DIRY[shootdir];
                    }
                    else
                    {
                        moving = true;
                    }
                }
                case(T_MIRROR_ROT ... T_MIRROR_ROT + 15)
                {
                    u8 d = mirror_reflect((obj >> 2) & 3, shootdir);
                    if(d < 4)
                    {
                        shooting = true;
                        shootdir = d;
                        shootx += DIRX[shootdir];
                        shooty += DIRY[shootdir];
                    }
                    else
                    {
                        // rotate clockwise
                        tiles[si] = (obj & 0xf0) + ((obj + 4) & 0xc);
                    }
                }
                case(T_ANTITANK ... T_ANTITANK + 15)
                {
                    u8 tdir = u8(obj - T_ANTITANK) >> 2;
                    if(((tdir + 2) & 3) == shootdir)
                        objects[si] = T_ANTITANK_B + tdir * 4;
                    else
                        moving = true;
                }
            }
        }
    }

    bool busy = shooting || moving;

    if(!busy && $just_pressed(A_BUTTON))
    {
        shootx = tankx + DIRX[tankdir];
        shooty = tanky + DIRY[tankdir];
        shootdir = tankdir;
        shooting = shootx < 16 && shooty < 16;
        first_move = true;
    }

    if($just_pressed(B_BUTTON))
    {
        can_pan = true;
        b_pressed_time = $millis();
    }

    if($just_released(B_BUTTON) && $millis() < b_pressed_time + PAUSE_PRESS_MS)
    {
        state = STATE_PAUSE;
    }

    if(!busy && !$pressed(B_BUTTON))
    {
        if(btn_just_pressed(UP_BUTTON))
            process_tank_move(DIR_U);
        if(btn_just_pressed(RIGHT_BUTTON))
            process_tank_move(DIR_R);
        if(btn_just_pressed(DOWN_BUTTON))
            process_tank_move(DIR_D);
        if(btn_just_pressed(LEFT_BUTTON))
            process_tank_move(DIR_L);
    }

    if(can_pan && $pressed(B_BUTTON))
    {
        constexpr i8 PAN_SPEED = 3;
        if($pressed(UP_BUTTON  )) targety -= PAN_SPEED;
        if($pressed(DOWN_BUTTON)) targety += PAN_SPEED;
    }
    else
        adjust_to_tank();

    if(targety <  0) targety =  0;
    if(targety > 64) targety = 64;

    if(offy < targety) offy += (targety - offy + 3) / 4;
    if(offy > targety) offy -= (offy - targety + 3) / 4;

    render_level();

    if(can_pan && $pressed(B_BUTTON))
    {
        $draw_filled_rect(125, 0, 3, 64, BLACK);
        $draw_filled_rect(126, offy / 2, 2, 32, WHITE);
    }
}

void process_tank_move(u8 dir)
{
    first_move = true;

    if(tankdir != dir)
    {
        tankdir = dir;
        return;
    }

    i8 dx = DIRX[dir];
    i8 dy = DIRY[dir];
    u8 nx = tankx + dx;
    u8 ny = tanky + dy;

    if(solid(nx, ny))
        return;

    tankx = nx;
    tanky = ny;

    just_moved = true;
    just_moved_dir = dir;
}
